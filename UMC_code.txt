// class definition
------------------------- Head Sensor ---------------------------------
Class Head is

Signals :
receivedFromRight ( alarm : bool ),
update ( temp : int , offset : int [] )


Operations :

Vars :
rightSensor :obj ,
roundAlarmed :int = 0 ,
round :int ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50,
isAlarmed : bool = False,


State Top = begining, startRound , update , waiting , fire , safe

Transitions :

begining -> startRound { update( temp, offset) /
    temperature = temp; 
    offsetTemperature = offset; 
    round = offsetTemperature.length;
    }
   
startRound -> update { - [round > 0 ] /
    round = round - 1;
    if (temperature < threshold) {rightSensor . consecutiveAboveThreshold (0 , round)}
    else {rightSensor . consecutiveAboveThreshold (1 , round)} }

    
startRound -> safe { - [round == 0] / - }

update -> waiting { - / 
    temperature = temperature + offsetTemperature[round] }

waiting -> startRound { receivedFromRight ( alarm ) [ alarm == True && roundAlarmed < 2 ] /
    isAlarmed = alarm; roundAlarmed = roundAlarmed + 1; temperature = temperature + 10  }
    
waiting -> fire { receivedFromRight ( alarm ) [ alarm == True && roundAlarmed == 2 ] / 
    isAlarmed = alarm; roundAlarmed = roundAlarmed + 1 }

waiting -> startRound { receivedFromRight ( alarm ) [ alarm == False ] / 
    isAlarmed = alarm; roundAlarmed = 0 }


 

end Head




------------------------- Intermediate sensor ---------------------------------
Class Intermediate is

Signals :
consecutiveAboveThreshold ( consecutives : int, round : int ),
alarmFromLeft ( alarm : bool ),
receivedFromRight ( alarm : bool ),
update ( temp : int , offset : int [] )


Operations :

Vars :
rightSensor :obj ,
leftSensor :obj ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50 ,
isAlarmed : bool = False ,
nowRound : int ,


State Top = standby , update , alarm

Transitions :
standby -> update { consecutiveAboveThreshold ( consecutives, round ) [ temperature < threshold ] / 
    rightSensor . consecutiveAboveThreshold (0 , round ); nowRound = round }

standby -> update
{ consecutiveAboveThreshold ( consecutives , round ) [ consecutives < 2 && temperature >= threshold ] / 
    rightSensor . consecutiveAboveThreshold ( consecutives + 1 , round ); nowRound = round }
  
standby -> alarm { consecutiveAboveThreshold ( consecutives , round ) [ consecutives == 2 && temperature >= threshold ] / 
    isAlarmed = True; leftSensor . receivedFromRight ( isAlarmed ); rightSensor . alarmFromLeft ( isAlarmed ); nowRound = round }
    
standby -> alarm {alarmFromLeft (alarm) /
    isAlarmed = alarm; rightSensor . alarmFromLeft ( isAlarmed )}
    
standby -> standby { receivedFromRight ( alarm ) [alarm == False] / 
    isAlarmed = alarm; leftSensor . receivedFromRight ( isAlarmed ) }
    
standby -> alarm { receivedFromRight ( alarm ) [alarm == True] / 
    isAlarmed = alarm; leftSensor . receivedFromRight ( isAlarmed ) }
    
alarm -> update { - / temperature = temperature + 10 }

update -> standby { - / temperature = temperature + offsetTemperature[nowRound] }


standby -> standby { update( temp, offset) /
    temperature = temp; offsetTemperature = offset }
    
end Intermediate




------------------------- Tail Sensor ---------------------------------
Class Tail is

Signals:
consecutiveAboveThreshold ( consecutives : int , round : int ),
alarmFromLeft ( alarm : bool ) ,
update ( temp : int , offset : int [] )


Operations :

Vars :
leftSensor :obj ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50 ,
isAlarmed : bool = False ,
nowRound : int ,

State Top = standby , update , alarm

Transitions :
standby -> update { consecutiveAboveThreshold ( consecutives , round ) [ consecutives < 3 && temperature < threshold ] / 
    isAlarmed = False; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }

standby -> update
{ consecutiveAboveThreshold ( consecutives , round  ) [ consecutives < 2  ] / 
    isAlarmed = False; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }

standby -> alarm { consecutiveAboveThreshold ( consecutives , round ) [ consecutives >= 2 && temperature >= threshold ] / 
    isAlarmed = True; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }

standby -> alarm { alarmFromLeft ( alarm ) / 
    isAlarmed = alarm; }
    
standby -> standby { update( temp, offset) /
    temperature = temp; offsetTemperature = offset }

alarm -> update { - / temperature = temperature + 10  }

update -> standby { - / temperature = temperature + offsetTemperature[nowRound] }

end Tail


------------------------- Simulation Generator ---------------------------------
Class Simulator is


--------- Insert here the code generated by the C++ “UMC code generator” ---------


Abstractions{
State : inState ( sensor1 . fire ) -> Fire
State : inState ( sensor1 . safe ) -> Safe
State : sensor2 . isAlarmed == True -> Alarm 

}